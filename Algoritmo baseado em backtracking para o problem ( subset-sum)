flag = False

def print_subset_sum(i, n, _set, target_sum, subset):
    global flag
    # Se a soma alvo for zero, existe um subconjunto válido
    if target_sum == 0:
        # Imprime o subconjunto válido
        flag = True
        print("[", end=" ")
        for element in subset:
            print(element, end=" ")
        print("]", end=" ")
        return

    if i == n:
        # Retorna caso tenha alcançado o final do array
        return

    # Não considerar o elemento atual
    print_subset_sum(i + 1, n, _set, target_sum, subset)

    # Considerar o elemento atual, se ele for menor ou igual à soma alvo
    if _set[i] <= target_sum:
        # Adiciona o elemento atual ao subconjunto
        subset.append(_set[i])

        # Chamada recursiva considerando o elemento atual
        print_subset_sum(i + 1, n, _set, target_sum - _set[i], subset)

        # Remove o último elemento após a chamada recursiva para restaurar o estado original do subconjunto
        subset.pop()

# Código principal
if __name__ == "__main__":
    # Caso de teste 1
    set_1 = [1, 2, 1]
    sum_1 = 3
    n_1 = len(set_1)
    subset_1 = []
    print("Saída 1:")
    print_subset_sum(0, n_1, set_1, sum_1, subset_1)
    print()
    flag = False

    # Caso de teste 2
    set_2 = [3, 34, 4, 12, 5, 2]
    sum_2 = 30
    n_2 = len(set_2)
    subset_2 = []
    print("Saída 2:")
    print_subset_sum(0, n_2, set_2, sum_2, subset_2)
    if not flag:
        print("Não há subconjunto que satisfaça a condição")
